# 08 HTTP 헤더 2 - 캐시와 조건부 요청
## 8.1 캐시 기본 동작
### 캐시가 없을 때   
1. 클라이언트가 이미지요청
```
GET /star.jpg
```
2. 서버 반환해주는데 해당 star.jpg는 1.1MB이다.
   + HTTP 헤더 : 0.1MB
   + HTTP 바디 : 1.0MB
3. 이를 받아서 웹 브라우저에 보여준다.
4. 클라이언트가 같은 이미지를 또 요청
5. 서버는 이미지를 또 반환해준다.

### 캐시가 없을 때
- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느리다.
- 느린 사용자 경험

### 캐시 적용   
1. 클라이언트가 이미지요청
```
GET /star.jpg
```
2. cache-control 등등 cache에 해당하는 헤더가 붙어서 헤더전송
3. 이를 받아서 웹 브라우저에 보여준다.
4. 해당 결과를 브라우저 캐시에 저장한다.
5. 클라이언트가 이미지를 다시 보여줄 일이 있을때, 캐시를 확인해서 보여준다.

### 캐시 사용할 때
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
- 빠른 사용자 경험

### 캐시 시간 초과   
1. 캐시 유효시간이 지나면 다시 클라이언트는 서버에 요청한다.
2. 똑같은 메시지를 서버에서 받는다.
3. 응답결과를 다시 캐시에 저장한다.

<br>

- 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
- 이때 다시 네트워크 다운로드가 발생한다.

## 8.2 검증 헤더와 조건부 요청1
- 캐시 유효시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.
    1. 서버에서 기존 데이터를 변경함
    2. 서버에서 기존 데이터를 변경하지 않음

### 캐시 시간 초과
- 캐시 만료 후에도 서버에서 데이터를 변경하지 않았다면?
- 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.
- 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

> Last-Modified: ----    
> 데이터가 마지막에 수정된 시간
 
1. 클라이언트가 요청을 보낼 때 캐시가 가지고 있는, 데이터 최종 수정일을 같이 서버에 요청한다.
2. 데이터가 아직 수정되지 않았다면, 서버는 해당 캐시를 사용할 수 있다는 것을 알려준다.
- 서버는 이제 클라이언트가 가지고 있는 데이터를 날짜로 검증할 수 있다.
3. HTTP Body가 없이 304 Not Modified를 전송한다. + Last Modified
4. 클라이언트는 해당 캐시가 변경되지 않았다는 사실을 알게 되므로, 캐시를 다시 세팅하고 해당 캐시를 사용한다.

### 검증 헤더와 조건부 요청 정리
- 캐시 유효시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 NotModified + 헤더 메타 정보만 응답(바디X)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 클라이언트는 용량이 적은 헤더 정보만 다운로드
- 매우 실용적인 해결책

## 8.3 검증헤더와 조건부 요청 2
- 검증헤더 
    + 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    + Last-Modified, ETag
- 조건부 요청 헤더
    + 검증 헤더로 조건에 따른 분기
    + If-Modified-Since: Last-Modifed 사용
    + If-None-Match : ETag 사용
    + 조건이 만족하면 200 OK
    + 조건이 만족하지 않으면 304 Not Modified

**If-Modified-Since : 이후에 데이터가 수정 되었니?**   
- 데이터 미변경 예시 
    + 캐시와 서버가 같은 시간
    + 304 Not Modified 헤더 데이터만 전송(Body 미포함)
    + 전송용량 : 0.1MB
  
- 데이터 변경 예시
    + 캐시와 서버 다른시간
    + 200 OK, 모든 데이터 전송(BODY 포함)
    + 전송용량 : 1.1MB(헤더 0.1MB, 바디1.0MB)

### Last-Modified, If-Modified-Since 단점
- 1초 미만 단위로 캐시 조정이 불가능
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
    + 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### ETag, If-None-Match
- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.
- 데이터가 변경되면 이 이름을 바꾸어서 변경한다.(Hash를 다시 생성)
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

1. 클라이언트에서 서버에 요청을 보낸다.
2. 서버에서 ETag를 보내준다.
3. 브라우저 캐시에서 ETag를 저장한다.
4. 클라이언트는 브라우저 캐시에 저장된 ETag도 같이 전송한다. 
5. 서버에서는 클라이언트에서 받은 ETag랑 비교해서 같은지 다른지를 보낸다.
6. 같으면 304 Not Modified, 다르면 200 OK

### ETag, If-None-Match 정리
- 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 이 값을 서버에 제공
- 서버는 배타 오픈 기간인 3일동안 파일이 변경되어도 ETag를 동일하게 유지
- 애플리케이션 배포 기간에 맞추어서 ETag변경

## 8.4 캐시와 조건부 요청 헤더
### 캐시제어 헤더
- Cache-Control
  + Cache-Control: max-age
    * 캐시 유효 시간, 초 단위
  + Cache-Control: no-cache
    * 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
  + Cache-Control: no-store
    * 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)

- Pragma
    + Pragma:no-cache
    + HTTP 1.0 하위 호환

- Expires
    + 캐시 만료일을 정확한 날짜로 지정
    + HTTP 1.0 부터 사용
    + 지금은 더 유연한 Cache-Control: max-age 권장
    + Cache-Control: max-age와 함께 사용하면 Expired 무시

### 검증 헤더와 조건부 요청 헤더
- 검증 헤더
    + ETag:"v1.0", ETag: "asida123"
    + Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT
- 조건부 요청 헤더
    + If-Match, If-None-Match: ETag 값 사용
    + If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용

## 8.5 프록시 캐시
### 원 서버 직접 접근
한국에 있는 클라이언트 -> 미국에 있는 원 서버   
그래서 중간에 한국 어딘가에 프록시 캐시 서버를 둔다.   
(그래서 미국 원 서버를 통해서 요청을 받아 가는 것이 아니라, 클라이언트가 프록시 캐시서버에서 요청을 받아가도록)

처음 유저는 느릴 수도, 하지만 다음 유저부터는 빠르다.

- public 캐시 : 공용으로 사용하는 캐시
- private 캐시 : 로컬이나, 브라우저에 저장되는 캐시

### 캐시 지시어 
- Cache-Control: public 
    + 응답이 public 캐시에 저장되어도 됨
- Cache-Control: private
    + 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야함 (기본값)
- Cache-Control:max-age
    + 프록시 캐시에만 적용되는 max-age
- Age:60(HTTP 헤더)
    + 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)
## 8.6 캐시 무효화
- 확실한 캐시 무효화 응답
- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache
    + HTTP 1.0 하위 호환

### 캐시 지시어
- Cache-Control: no-cache
    + 데이터는 캐시해도 되지만, 항상 원서버에 검증하고 사용
- Cache-Control: no-store
    + 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하가 최대한 빨리 삭제)
- Cache-Control: must-revalidate
    + 캐시 만료후 최초 조회시 원 서버에 검증해야함
    + 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504 Gateway Timeout
    + must-revalidat는 캐시 유효 시간이라면 캐시를 사용함
- Pragma: no-cache
    + HTTP 1.0 하위 호환

> 현재 사용자의 통장잔고 이런거는 계속 갱신될 수 있으므로 절대로 캐시 하면 안된다.

### no-cache vs must-revalidate
#### 1-1 no-cache 기본 동작
1. 캐시 서버 요청 (no-cache + ETag)
2. 원 서버 요청 (no-cache + ETag)
3. 원 서버 검증
4. 원서버 : 응답 - 304 Not Modified
5. 프록시 서버 : 응답 - 304 Not Modified
6. 캐시 데이터 사용

#### 1-2 no-cache 순간 네트워크 단절(원 서버 접근X)
1. 캐시 서버 요청 (no-cache + ETag)
2. 원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라서 캐시 데이터를 반환할 수 있다.
- Error or 200 OK (오류 보다는 오래된 데이터라도 보여주자)
3. 프록시 서버 : 응답 200 OK

#### 2-1 must-revalidate 순간 네트워크 단절(원 서버 접근X)
1. 캐시 서버 요청 (must-revalidate + ETag)
2. 원 서버에 접근할 수 없는 경우 항상 오류가 발생해야 함.
- 504 Gateway Timeout(매우 중요한 돈과 관련된 결과로 생각해 보자)
3. 프록시 서버 : 응답 504 Gateway Timeout  