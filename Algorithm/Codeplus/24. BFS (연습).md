# BFS (연습)

## 문제
> [알고리즘 중급 1 - BFS (연습)](https://www.acmicpc.net/workbook/view/3976)

<details>
<summary>1. 뱀과 사다리 게임</summary>
<div markdown='1'>

- 100개의 칸으로 나누어져 있는 게임이 있다. 1에서 100으로 가야 한다.
- 주사위를 굴려 나온 수 만큼 이동할 수 있으며, 도착한 칸이 사다리인 경우에는 사다리를 타고 더 큰 번호의 칸으로, 뱀인 경우에는 더 작은 번호의 칸으로 이동한다.
- 주사위에 나온 수를 정할 수 있을 때, 최소 몇 번 굴려야 하는지 구하는 문제
    + 왜 BFS? 
    + 시작점과 도착점이 정해져 있고, 최소 값을 구하는 문제이기 때문
- 까다로운 점은 뱀과 사다리의 처리
- 도착한 이후에 뱀이나 사다리인 경우를 처리해야 한다.
- 게임에서 뱀과 사다리의 구분은 중요하지만, 구현에서는 별로 중요하지 않다.
- x -> y로 간다는 점만 중요하다.
- 따라서 새로운 배열 next[x]를 만들어서, x에 도착한 이후에 가야할 곳을 모두 기록한다.
    + 뱀이나 사다리인 경우 : `next[x] = y`
    + 일반 칸인 경우 : `next[x] = x`

1. 
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int[] visited = new int[101];
        int[] next = new int[101];
        for (int i = 1; i <= 100; i++) {
            next[i] = i;
            visited[i] = -1;
        }
        for (int i = 0; i < n+m; i++) {
            stk = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(stk.nextToken());
            int y = Integer.parseInt(stk.nextToken());
            next[x] = y;
        }
        ArrayDeque<Integer> q = new ArrayDeque<>();

        q.push(1);
        visited[1] = 0;
        while(!q.isEmpty()){
            int now = q.poll();
            if(now==100){
                System.out.println(visited[100]);
                return;
            }
            for (int i = 1; i <=6 ; i++) {
                int tmp = now + i;
                if(tmp<=100){
                    tmp = next[tmp];
                    if(visited[tmp]==-1){
                        visited[tmp] = visited[now]+1;
                        q.add(tmp);
                    }
                }else break;
            }
        }
    }
}
```
나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int[] visited = new int[101];

        HashMap<Integer,Integer> ladder = new HashMap<>();
        HashMap<Integer,Integer> snake = new HashMap<>();
        for (int i = 0; i < n; i++) {
            stk = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(stk.nextToken());
            int y = Integer.parseInt(stk.nextToken());
            ladder.put(x,y);
        }
        for (int i = 0; i < m; i++) {
            stk = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(stk.nextToken());
            int v = Integer.parseInt(stk.nextToken());
            snake.put(u,v);
        }
        ArrayDeque<Integer> q = new ArrayDeque<>();
        Arrays.fill(visited,-1);
        q.push(1);
        visited[1] = 0;
        while(!q.isEmpty()){
            int now = q.poll();
            if(now==100){
                System.out.println(visited[100]);
                return;
            }
            for (int i = 1; i <=6 ; i++) {
                int next = now + i;
                if(next<=100){
                    if(visited[next]==-1){
                        if(ladder.containsKey(next)){
                            int ladderValue = ladder.get(next);
                            if(visited[ladderValue]==-1){
                                visited[ladderValue] = visited[now]+1;
                                q.add(ladderValue);
                            }
                        } else if(snake.containsKey(next)){
                            int snakeValue = snake.get(next);
                            if(visited[snakeValue]==-1){
                                visited[snakeValue] = visited[now]+1;
                                q.add(snakeValue);
                            }
                        }else{
                            visited[next] = visited[now]+1;
                            q.add(next);
                        }
                    }
                }
                if(next>100) break;
            }
        }
    }
}
```
</div>
</details>

<details>
<summary>2. 데스 나이트</summary>
<div markdown='1'>

- 데스 나이트는 (r,c)에서 (r-2,c-1), (r-2,c+1), (r,c-2), (r,c+2), (r+2,c-1), (r+2,c+1)로 이동할 수 있는 말이다.
- 크기가 N x N 인 체스판과 두 칸 (r1,c1), (r2,c2)가 주어졌을 때, (r1,c1)에서 (r2,c2)로 가는 **최소 이동 횟수**를 구하는 문제
- 5 <= N <= 200  
- BFS로 해결할 수 있는 문제이다.
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx={-2,-2,0,0,2,2},dy={-1,1,-2,2,-1,1};
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int startX = Integer.parseInt(stk.nextToken());
        int startY = Integer.parseInt(stk.nextToken());
        int endX = Integer.parseInt(stk.nextToken());
        int endY = Integer.parseInt(stk.nextToken());
        int[][] board = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i],-1);
        }
        board[startX][startY] = 0;
        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(startX,startY));
        while(!q.isEmpty()){
            Node now = q.poll();
            int y = now.y;
            int x = now.x;
            if(x==endX&&y==endY){
                System.out.println(board[x][y]);
                return;
            }
            for (int i = 0; i < 6; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx>=0&&ny>=0&&nx<n&&ny<n&&board[nx][ny]==-1){
                    board[nx][ny] = board[x][y]+1;
                    q.add(new Node(nx,ny));
                }
            }
        }
        System.out.println(-1);
    }
    static class Node{
        int x;
        int y;
        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```
</div>
</details>

<details>
<summary>3. DSLR</summary>
<div markdown='1'>

- 네 자리 숫자 A와 B가 주어졌을때, A -> B로 바꾸는 최소 연산 횟수
    + D: N -> 2*N
    + S: N -> N-1
    + L: 한자리씩 왼쪽으로
    + R: 한자리씩 오른쪽으로
- 이 문제는 최소값을 구해야 하는건 맞지만 어떠한 과정을 거쳐야 하는지를 구해야 한다.
- 배열을 하나 더 이용해서 어떤 과정을 거쳤는지를 저장해야한다.
- `how[i] = i를 어떻게 만들었는지`
> BFS 역추적을 할때 전체 과정을 기록하는 것은 조심해야 한다.
> - 해당 전체 과정이 얼마나 길지 모르기 때문이다.
> - 즉, 모두 기록하면 공간이 매우 많이 필요하게 될 수 있다.

풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        while(n-- > 0){
            StringTokenizer stk = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(stk.nextToken());
            int b = Integer.parseInt(stk.nextToken());
            int[] visited = new int[10000];
            char[] how = new char[10000];
            Arrays.fill(visited,-1);

            ArrayDeque<Integer> q = new ArrayDeque<>();
            q.add(a);
            visited[a] = Integer.MAX_VALUE;
            while(!q.isEmpty()) {
                int now = q.poll();
                if (now == b) {
                    StringBuilder tmp = new StringBuilder();
                    int chk = now;
                    while(chk!=a){
                        tmp.append(how[chk]);
                        chk = visited[chk];
                    }
                    sb.append(tmp.reverse()).append('\n');
                    break;
                }
                int d = (now * 2) % 10000;
                if (visited[d]==-1) {
                    visited[d] = now;
                    how[d] = 'D';
                    q.add(d);
                }
                int s = (now == 0) ? 9999 : now - 1;
                if (visited[s]==-1) {
                    visited[s] = now;
                    how[s] = 'S';
                    q.add(s);
                }
                int l = now / 1000 + (now % 1000) * 10;
                if (visited[l]==-1) {
                    visited[l] = now;
                    how[l]='L';
                    q.add(l);
                }
                int r = (now % 10) * 1000 + (now / 10);
                if (visited[r]==-1) {
                    visited[r] = now;
                    how[r]='R';
                    q.add(r);
                }
            }
        }
        System.out.println(sb);
    }

}
```
나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        while(n-- > 0){
            StringTokenizer stk = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(stk.nextToken());
            int b = Integer.parseInt(stk.nextToken());
            boolean[] visited = new boolean[10000];
            ArrayDeque<Node> q = new ArrayDeque<>();
            q.add(new Node(a,""));
            visited[a] = true;
            while(!q.isEmpty()) {
                Node node = q.poll();
                int now = node.now;
                String str = node.str;
                if (now == b) {
                    sb.append(str).append('\n');
                    break;
                }
                int d = (now * 2) % 10000;
                if (!visited[d]) {
                    visited[d] = true;
                    q.add(new Node(d, str + "D"));
                }
                int s = (now == 0) ? 9999 : now - 1;
                if (!visited[s]) {
                    visited[s] = true;
                    q.add(new Node(s, str + "S"));
                }
                int l = now / 1000 + (now % 1000) * 10;
                if (!visited[l]) {
                    visited[l] = true;
                    q.add(new Node(l, str + "L"));
                }
                int r = (now % 10) * 1000 + (now / 10);
                if (!visited[r]) {
                    visited[r] = true;
                    q.add(new Node(r, str + "R"));
                }
            }
        }
        System.out.println(sb);
    }
    static class Node{
        int now;
        String str;
        public Node(int now, String str) {
            this.now = now;
            this.str = str;
        }
    }
}
```
</div>
</details>

<details>
<summary>4. 연구소</summary>
<div markdown='1'>

- N x M 크기의 직사각형 지도가 있고, 1 x 1크기의 칸으로 나누어져 있다. (3 <= N, M <= 8)
- 칸: 빈 칸, 벽
- 일부 빈 칸에는 바이러스가 있고, 인접한 빈 칸으로 계속해서 퍼져 나간다.
- 벽을 3개 세워서 바이러스가 퍼질 수 없는 곳의 크기를 구하는 문제
- 벽을 세운다는 내용을 잠시 제외하면 입력으로 주어진 상태에서 바이러스가 퍼질 수 없는 역역의 크기는 BFS(DFS)로 구할 수 있다.
- 칸은 정점, 인접한 칸의 관계는 간선으로 나타내면, 바이러스에서 시작해서 연결된 모든 정점을 방문하는 문제가 되어버린다.
- 벽을 3개 세우는 경우의 수는 : (NM)^3
- 벽을 세운 다음 안전 영역의 크기를 구하는 방법: BFS, DFS = O(NM)
- 총 O((NM)^4)가 나오는데, N, M <= 8이기 때문에, 시간 안에 해결할 수 있다.

```java
import java.io.*;
import java.util.*;

public class Main {
    static int n,m;
    static int[] dx ={-1,1,0,0},dy={0,0,1,-1};
    static int[][] board;
    static int ans=0;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        n = Integer.parseInt(stk.nextToken());
        m = Integer.parseInt(stk.nextToken());
        board = new int[n][m];
        for (int i = 0; i < n; i++) {
            stk = new StringTokenizer(br.readLine());
            for (int j = 0; j < m; j++) {
                board[i][j] = Integer.parseInt(stk.nextToken());
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(board[i][j]==0){
                    board[i][j] = 1;
                    for (int k = 0; k < n; k++) {
                        for (int l = 0; l < m; l++) {
                            if(board[k][l]==0){
                                board[k][l] = 1;
                                for (int o = 0; o < n; o++) {
                                    for (int p = 0; p < m; p++) {
                                        if(board[o][p]==0){
                                            board[o][p] = 1;
                                            bfs();
                                            board[o][p] = 0;
                                        }
                                    }
                                }
                                board[k][l]=0;
                            }
                        }
                    }
                    board[i][j] = 0;
                }
            }
        }
        System.out.println(ans);
    }
    static void bfs(){
        ArrayDeque<Node> q = new ArrayDeque<>();
        int[][] visited = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                visited[i][j] = board[i][j];
                if(visited[i][j]==2){
                    q.add(new Node(j,i));
                }
            }
        }
        while(!q.isEmpty()){
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx>=0&&ny>=0&&nx<m&&ny<n&&visited[ny][nx]==0){
                    q.add(new Node(nx,ny));
                    visited[ny][nx] = 2;
                }
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(visited[i][j]==0) result++;
            }
        }
        ans = Math.max(result,ans);
    }
    static class Node{
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```
</div>
</details>

<details>
<summary>5. 돌 그룹</summary>
<div markdown='1'>

- 돌이 3개의 그룹으로 나누어져 있고, 각 그룹에는 돌이 A,B,C개 있다, (A,B,C <= 500)
- 돌은 단계별로 움직이고, 각 단계는 다음과 같다.
- 크기가 같지 않은 두 그룹을 고른다. 돌의 개수가 작은 쪽을 X, 큰 쪽을 Y라고 한다.
- X에 있는 돌의 개수를 X+X개로, Y에 있는 돌의 개수를 Y-X로 만든다.
- A,B,C가 주어졌을 때, 모든 그룹에 들어있는 돌의 개수를 같게 만들 수 있는지 구하는 문제
- BFS로 해결할 수 있다.
- 정점 (A, B, C) 또는 (A, B)
- 전체 정점의 개수 : A + B + C개
    + 아무리 이동시켜도 돌의 개수는 같다. (X,Y) = X+Y : (X+X, Y-X) = X+Y
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(stk.nextToken());
        int b = Integer.parseInt(stk.nextToken());
        int c = Integer.parseInt(stk.nextToken());
        boolean[][] visited = new boolean[1501][1501];
        ArrayDeque<Node> q = new ArrayDeque<>();
        Node start = sort(a, b, c);
        q.add(start);
        if ((a + b + c) % 3 != 0) {
            System.out.println(0);
            return;
        }
        visited[start.a][start.b] = true;
        while (!q.isEmpty()) {
            Node node = q.poll();
            int x = node.a;
            int y = node.b;
            int z = node.c;
            if (x == y && y == z) {
                System.out.println(1);
                return;
            }
            if (x < y) {
                if (!visited[x + x][y - x]) {
                    visited[x + x][y - x] = true;
                    Node next = sort(x + x, y - x, z);
                    q.add(next);
                }
            }
            if (y < z && y + y <= 500) {
                Node next = sort(x, y + y, z - y);
                if (!visited[y + y][z - y]) {
                    visited[y + y][z - y] = true;
                    q.add(next);
                }
            }
            if (x < z && x + x <= 500) {
                Node next = sort(x + x, y, z - x);
                if (!visited[x + x][z - x]) {
                    visited[x + x][z - x] = true;
                    q.add(next);
                }
            }
        }
        System.out.println(0);
    }
    static Node sort(int a, int b, int c) {
        int min = Math.min(a, Math.min(b, c));
        int max = Math.max(a, Math.max(b, c));
        int center = a + b + c - max - min;
        return new Node(min, center, max);
    }

    static class Node {
        int a;
        int b;
        int c;

        public Node(int x, int y, int z) {
            this.a = x;
            this.b = y;
            this.c = z;
        }
    }
}
```
</div>
</details>

<details>
<summary>6. 벽 부수고 이동하기</summary>
<div markdown='1'>

- N x M 의 행렬로 나타내는 지도에서 (1,1)에서 (N,M)으로 최단 거리로 이동하는 문제
- 0은 빈 칸, 1은 벽
- 단, 벽은 한 번 부수고 지나갈 수 있다.
- 벽을 부순다는 조건이 없으면 일반적인 미로 탐색 문제이다.
- 어떤 칸에 방문했을 때, 벽을 부순적이 있는 경우와 아직 부순적이 없는 경우는 다른 경우 이기 때문에
- 상태 (i,j) 대신에 (i,j,k) (k==0이면 벽을 부순적이 없음, 1이면 있음)으로 BFS탐색을 진행한다.
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int[][] board = new int[n][m];
        boolean[][][] visited = new boolean[2][n][m];
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j) - '0';
            }
        }
        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(0, 0, 0, 1));
        visited[0][0][0] = true;
        visited[1][0][0] = true;
        while (!q.isEmpty()) {
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            int b = node.b;
            int c = node.c;
            if (x == m - 1 && y == n - 1) {
                System.out.println(c);
                return;
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;

                if (board[ny][nx] == 1 && b == 0 && !visited[1][ny][nx]) {
                    visited[1][ny][nx] = true;
                    q.add(new Node(nx, ny, b + 1, c + 1));
                } else if (board[ny][nx] == 0 && b == 1 && !visited[1][ny][nx]) {
                    visited[1][ny][nx] = true;
                    q.add(new Node(nx, ny, b, c + 1));
                } else if (board[ny][nx] == 0 && b == 0&& !visited[0][ny][nx]) {
                    visited[0][ny][nx] = true;
                    visited[1][ny][nx] = true;
                    q.add(new Node(nx, ny, b, c + 1));
                }
            }
        }
        System.out.println(-1);
    }

    static class Node  {
        int x;
        int y;
        int b;
        int c;

        public Node(int x, int y, int b, int c) {
            this.x = x;
            this.y = y;
            this.b = b;
            this.c = c;
        }
    }
}
```
</div>
</details>

<details>
<summary>7. 벽 부수고 이동하기 4</summary>
<div markdown='1'>

- N x M 의 크기의 지도가 있다.
- 0은 이동할 수 있는 칸(빈 칸), 1은 이동할 수 없는 곳(벽)
- 두 칸이 변을 공유할 때, 인접하다고 한다.
- 각각의 벽을 빈 칸으로 바꾸고, 그 위치에서 이동할 수 있는 (칸의 개수 % 10)을 구해보자.
- 매번 벽에서 빈 칸을 탐색하는 것은 비효율적이다.
- 이동할 수 있는 빈 칸을 모두 그룹 짓고 몇 개의 칸을 이루어져 있는지 계산해보자. -> O(NM) + O(NM)
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int[][] board = new int[n][m];
        int[][] group = new int[n][m];
        HashMap<Integer,Integer> groupSize = new HashMap<>();
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j) - '0';
            }
        }
        int num = 0;
        boolean[][] visited = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(board[i][j]==0&&!visited[i][j]){
                    int size = 1;
                    visited[i][j] = true;
                    group[i][j] = ++num;
                    ArrayDeque<Node> q = new ArrayDeque<>();
                    q.add(new Node(j,i));
                    while(!q.isEmpty()){
                        Node node = q.poll();
                        int x = node.x;
                        int y = node.y;
                        for (int k = 0; k < 4; k++) {
                            int nx = x + dx[k];
                            int ny = y + dy[k];
                            if(nx<0||ny<0||nx>=m||ny>=n) continue;
                            if(!visited[ny][nx]&&board[ny][nx]==0){
                                visited[ny][nx] = true;
                                group[ny][nx] = num;
                                size++;
                                q.add(new Node(nx,ny));
                            }
                        }
                    }
                    groupSize.put(num,size);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int cnt = 0;
                if(board[i][j]==1){
                    cnt++;
                    HashSet<Integer> set = new HashSet<>();
                    for (int k = 0; k < 4; k++) {
                        int nx = j + dx[k];
                        int ny = i + dy[k];
                        if(ny<0||nx<0||ny>=n||nx>=m) continue;
                        if(board[ny][nx]==0){
                            set.add(group[ny][nx]);
                        }
                    }
                    for (Integer g : set) {
                        cnt += groupSize.get(g);
                    }
                }
                sb.append(cnt%10);
            }
            sb.append('\n');
        }
        System.out.print(sb);
    }

    static class Node  {
        int x;
        int y;
        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```
</div>
</details>

<details>
<summary>8. 벽 부수고 이동하기 2</summary>
<div markdown='1'>

- N x M 의 행렬로 나타내는 지도에서 (1,1)에서 (N,M)으로 최단 거리로 이동하는 문제
- 0은 빈 칸, 1은 벽
- 단, 벽은 K번 부수고 지나갈 수 있다.
- 벽을 부순다는 조건이 없으면 일반적인 미로 탐색 문제이다.
- 어떤 칸을 방문했을 때, 벽을 부순 적이 있는 경우와 아직 부순 적이 없는 경우는 다른 경우이기 때문에, 상태 (i,j) 대신에 (i,j,b) (b는 벽을 부순 횟수) 으로 BFS 탐색을 진행한다.
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int k = Integer.parseInt(stk.nextToken());
        int[][] board = new int[n][m];
        boolean[][][] visited = new boolean[k+1][n][m];
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j) - '0';
            }
        }
        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(0, 0, 0, 1));
        for (int i = 0; i <= k; i++) {
            visited[i][0][0] = true;
        }
        while (!q.isEmpty()) {
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            int d = node.d;
            int c = node.c;
            if(x==m-1&&y==n-1) {
                System.out.println(c);
                return;
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx<0||ny<0||nx>=m||ny>=n) continue;
                if(d+1<=k&&!visited[d+1][ny][nx]&&board[ny][nx]==1){
                    visited[d+1][ny][nx] = true;
                    q.add(new Node(nx,ny,d+1,c+1));
                }
                else if(!visited[d][ny][nx]&&board[ny][nx]==0){
                    visited[d][ny][nx] = true;
                    q.add(new Node(nx,ny,d,c+1));
                }
            }
        }
        System.out.println(-1);
    }

    static class Node {
        int x;
        int y;
        int d;
        int c;

        public Node(int x, int y, int d, int c) {
            this.x = x;
            this.y = y;
            this.d = d;
            this.c = c;
        }
    }
}
```
</div>
</details>

<details>
<summary>9. 벽 부수고 이동하기 3</summary>
<div markdown='1'>

- N x M 의 행렬로 나타내는 지도에서 (1,1)에서 (N,M)으로 최단 거리로 이동하는 문제
- 0은 빈 칸, 1은 벽
- 이동할 때마다 낮과 밤이 바뀐다.
- 단, 벽은 K번 부수고 지나갈 수 있고, 낮에만 부술 수 있다.
- 벽을 부순다는 조건이 없으면 일반적인 미로 탐색 문제이다.
- 어떤 칸을 방문했을 때, 벽을 부순 적이 있는 경우와 아직 부순 적이 없는 경우는 다른 경우이다.
- 낮과 밤도 다른 경우이다.
- 상태 (i,j) 대신에 (i,j,b,t) (b는 벽을 부순 횟수,t=낮/밤) 으로 BFS 탐색을 진행한다.
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int k = Integer.parseInt(stk.nextToken());
        int[][] board = new int[n][m];
        boolean[][][][] visited = new boolean[2][k + 1][n][m];

        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j) - '0';
            }
        }
        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(0, 0, 0, 1, 0));
        visited[0][0][0][0] = true;

        while (!q.isEmpty()) {
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            int d = node.d;
            int c = node.c;
            int day = node.day;
            if (x == m - 1 && y == n - 1) {
                System.out.println(c);
                return;
            }
            if (day == 0 && !visited[1][d][y][x]) {
                visited[1][d][y][x] = true;
                q.add(new Node(x, y, d, c + 1, 1));
            } else if (day == 1 && !visited[0][d][y][x]) {
                visited[0][d][y][x] = true;
                q.add(new Node(x, y, d, c + 1, 0));
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
                if (day == 0 && d + 1 <= k && !visited[1][d + 1][ny][nx] && board[ny][nx] == 1) {
                    visited[1][d + 1][ny][nx] = true;
                    q.add(new Node(nx, ny, d + 1, c + 1, 1));
                } else if (!visited[(day+1)%2][d][ny][nx] && board[ny][nx] == 0) {
                    visited[(day+1)%2][d][ny][nx]=true;
                    q.add(new Node(nx, ny, d, c + 1, (day+1)%2));
                }
            }
        }
        System.out.println(-1);
    }

    static class Node {
        int x;
        int y;
        int d;
        int c;
        int day;

        public Node(int x, int y, int d, int c, int day) {
            this.x = x;
            this.y = y;
            this.d = d;
            this.c = c;
            this.day = day;
        }
    }
}
```
</div>
</details>

<details>
<summary>10. 움직이는 미로 탈출</summary>
<div markdown='1'>

- 크기가 8 x 8인 체스판이 있고, 모든 칸에는 빈 칸 또는 벽이다.
- 가장 왼쪽 아랫 칸에서 가장 오른쪽 윗 칸으로 이동할 수 있는지 없는지 구하는 문제
- 벽은 1초에 한 칸씩 아래로 내려온다.
- 벽이 있는 칸으로 이동할 수 없고, 이동한 칸에 벽이 내려오면 더 이상 이동할 수 없다.
- 8초가 지나면 벽이 없어진다.
- 지도를 총 9개 준비해서, 0초 후, 1초 후, ..., 8초 후를 만들고 BFS를 수행할 수 있다.
- (r,c,t): t초 후에 (r,c)에 있을 때 최소 시간
- 8초 후부터는 t를 증가시키는 의미가 없다.
- 실제로 지도를 9개나 만들 필요는 없다.
- 특정 시점이 t초 후에 벽이 있는지 없는지는 알아낼 수 있기 때문이다.
- t초후에 (r,c)로 벽이 내려왔다면, 그 벽은 (r-t,c)에 있던 벽이다.

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {0, 0, 1, -1, -1, -1, 1, 1,0}, dy = {-1, 1, 0, 0, 1, -1, 1, -1,0};
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        boolean[][][] visited = new boolean[8][8][9];
        char[][] board = new char[8][8];
        for (int i = 0; i < 8; i++) {
            String s = br.readLine();
            for (int j = 0; j < 8; j++) {
                board[i][j] = s.charAt(j);
            }
        }

        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(0, 7,0));
        visited[7][0][0] = true;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int s = 0; s < size; s++) {
                Node node = q.poll();
                int x = node.x;
                int y = node.y;
                int c = node.c;
                if (x == 7 && y == 0) {
                    System.out.println(1);
                    return;
                }
                for (int i = 0; i < 9; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];
                    int nc = Math.min(c+1,8);
                    if(nx>=0&&ny>=0&&nx<8&&ny<8){
                        if(ny-c>=0&&board[ny-c][nx]=='#') continue;
                        if(ny-c-1>=0&&board[ny-c-1][nx]=='#') continue;
                        if(!visited[ny][nx][nc]){
                            visited[ny][nx][nc] = true;
                            q.add(new Node(nx,ny,nc));
                        }
                    }
                }
            }
        }
        System.out.println(0);
    }

    static class Node {
        int x;
        int y;
        int c;
        public Node(int x, int y,int c) {
            this.x = x;
            this.y = y;
            this.c = c;
        }
    }
}
```
나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {0, 0, 1, -1, -1, -1, 1, 1,0}, dy = {-1, 1, 0, 0, 1, -1, 1, -1,0};
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        boolean[][] visited = new boolean[8][8];
        char[][] board = new char[8][8];
        for (int i = 0; i < 8; i++) {
            String s = br.readLine();
            for (int j = 0; j < 8; j++) {
                board[i][j] = s.charAt(j);
            }
        }

        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(new Node(0, 7));
        visited[7][0] = true;
        while (!q.isEmpty()) {
            int size = q.size();
            visited = new boolean[8][8];
            for (int s = 0; s < size; s++) {
                Node node = q.poll();
                int x = node.x;
                int y = node.y;
                if (x == 7 && y == 0) {
                    System.out.println(1);
                    return;
                }
                if (board[y][x] == '#') {
                    continue;
                }
                for (int i = 0; i < 9; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];
                    if(nx>=0&&ny>=0&&nx<8&&ny<8&&!visited[ny][nx]&&board[ny][nx]!='#'){
                        visited[ny][nx] = true;
                        q.add(new Node(nx,ny));
                    }
                }
            }
            board = move(board);
        }
        System.out.println(0);
    }
    static char[][] move(char[][] board){
        char[][] movedMap = new char[8][8];
        for (int j = 0; j < 8; j++) {
            Arrays.fill(movedMap[j],'.');
        }
        for (int i = 7; i > 0; i--) {
            for (int j = 0; j < 8; j++) {
                if(board[i-1][j]=='#'){
                    movedMap[i][j] = '#';
                    movedMap[i-1][j] = '.';
                }
            }
        }
        return movedMap;
    }

    static class Node {
        int x;
        int y;
        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```

</div>
</details>

<details>
<summary>11. 탈출</summary>
<div markdown='1'>

- 지도는 R행 C열이다
- 비어있는 곳은 '.'
- 물이 차있는 지역은 '*'
- 돌은 'X'
- 비버의 굴은 'D'
- 고슴도치의 위치는 'S'
- 먼저, 물이 언제 차는지 미리 구해 놓은 다음에 고슴도치를 그 다음에 이동시킨다.

나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {0, 0, 1, -1}, dy = {-1, 1, 0, 0};
    static boolean[][] waterVisited;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(stk.nextToken());
        int m = Integer.parseInt(stk.nextToken());
        int endX=0,endY=0;
        boolean[][] visited = new boolean[n][m];
        waterVisited = new boolean[n][m];
        char[][] board = new char[n][m];
        Node unit ;
        ArrayDeque<Node> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j);
                if(board[i][j]== 'S'){
                    unit = new Node(j,i,0);
                    q.add(unit);
                    visited[i][j] = true;
                }else if(board[i][j]=='D'){
                    endX = j;
                    endY = i;
                }
            }
        }
        while (!q.isEmpty()) {
            int size = q.size();
            char[][] nextWater = waterMove(board);
            for (int i = 0; i < size; i++) {
                Node node = q.poll();
                int x = node.x;
                int y = node.y;
                int c = node.c;
                if(x==endX&&y==endY){
                    System.out.println(c);
                    return;
                }
                for (int j = 0; j < 4; j++) {
                    int nx = x + dx[j];
                    int ny = y + dy[j];
                    if(nx>=0&&ny>=0&&nx<m&&ny<n&&(nextWater[ny][nx]=='.'||nextWater[ny][nx]=='D')&&!visited[ny][nx]){
                        visited[ny][nx] = true;
                        q.add(new Node(nx,ny,c+1));
                    }
                }
            }
            board = nextWater;
        }
        System.out.println("KAKTUS");
    }
    static char[][] waterMove(char[][] board){
        int n = board.length;
        int m = board[0].length;
        char[][] movedMap = new char[n][m];
        ArrayDeque<Node> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(board[i][j]=='*'&&!waterVisited[i][j]){
                    q.add(new Node(j,i,0));
                    waterVisited[i][j] = true;
                }
                movedMap[i][j] = board[i][j];
            }
        }
        while(!q.isEmpty()){
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx>=0&&ny>=0&&nx<m&&ny<n&&(board[ny][nx]=='.'||board[ny][nx]=='S')){
                    movedMap[ny][nx] = '*';
                }
            }
        }
        return movedMap;
    }

    static class Node {
        int x;
        int y;
        int c;
        public Node(int x, int y,int c) {
            this.x = x;
            this.y = y;
            this.c = c;
        }
    }
}
```
</div>
</details>

<details>
<summary>12. 아기 상어</summary>
<div markdown='1'>

- N x N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. N <= 20
- 공간은 1 x 1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.
- 아기 상어와 물고기는 모두 크기를 가지고 있다. 아기 상어의 크기는 2, 1초에 상하좌우로 인접한 한 칸씩 이동한다.
- 아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.
- 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.
- 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.
- 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.
    + 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야 하는 칸의 개수의 최소 값이다.
    + 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.
- 이동은 1초가 걸리고, 먹는데 걸리는 시간은 없다. 물고기를 먹으면 빈 칸이 된다.
- 아기 상어가 자신의 크기와 같은 수의 물고기를 먹을 때마다 크기가 1 증가한다.
- 엄마 상어에게 요청하지 않고, 몇 초 동안 물고기를 잡아먹을 수 있는지 구하는 문제
- 거리가 가장 가까운 물고기를 찾기 위해 BFS를 이용해야 한다. 
    + BFS 한 번의 시간 복잡도는 O(N^2)이다.
- 만약, 모든 칸에 물고기가 있고, 상어가 이 물고기를 다 먹을 수 있다면 최대 N^2번 BFS를 수행한다.
- 총 O(N^4)이고, N <= 20이기 때문에, 시간 안에 해결할 수 있다.

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {0, 0, 1, -1}, dy = {-1, 1, 0, 0};
    static int[][] board;
    static int n, ans = 0;
    static Node shark = new Node(0, 0, 0, 0,0);

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        board = new int[n][n];
        ArrayDeque<Node> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            StringTokenizer stk = new StringTokenizer(br.readLine());
            for (int j = 0; j < n; j++) {
                board[i][j] = Integer.parseInt(stk.nextToken());
                if (board[i][j] == 9) shark = new Node(j, i, 2, 0,0);
            }
        }
        int[][] tmp = findEat();
        while (checkAndUpdate(tmp)) {
            tmp = findEat();
        }
        System.out.println(ans);
    }

    static int[][] findEat() {
        ArrayDeque<Node> q = new ArrayDeque<>();
        q.add(shark);
        boolean[][] visited = new boolean[n][n];
        visited[shark.y][shark.x] = true;
        int[][] eatOk = new int[n][n];
        while (!q.isEmpty()) {
            int size = q.size();
            boolean find = false;
            for (int j = 0; j < size; j++) {
                Node node = q.poll();
                int x = node.x;
                int y = node.y;
                int s = node.s;
                int e = node.e;
                int c = node.c;
                if (board[y][x]!=0&&board[y][x]<s) {
                    eatOk[y][x] = c;
                    find = true;
                    continue;
                }
                for (int i = 0; i < 4; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];
                    if (nx >= 0 && ny >= 0 && nx < n && ny < n && !visited[ny][nx] && board[ny][nx] <= s) {
                        visited[ny][nx] = true;
                        q.add(new Node(nx, ny, s, e,c+1));
                    }
                }
            }
            if(find) break;
        }
        return eatOk;
    }

    static boolean checkAndUpdate(int[][] eatOk) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (eatOk[i][j]>0) {
                    board[shark.y][shark.x] = 0;
                    ans += eatOk[i][j];
                    shark.x = j;
                    shark.y = i;
                    shark.e += 1;
                    if (shark.e == shark.s) {
                        shark.s += 1;
                        shark.e = 0;
                    }
                    board[i][j] = 0;
                    return true;
                }
            }
        }
        return false;
    }

    static class Node {
        int x;
        int y;
        int s;
        int e;
        int c;

        public Node(int x, int y, int s, int e, int c) {
            this.x = x;
            this.y = y;
            this.s = s;
            this.e = e;
            this.c = c;
        }
    }
}
```
</div>
</details>

<details>
<summary>13. 레이저 통신</summary>
<div markdown='1'>

- 크기가 W x H인 지도가 주어졌을 때, 두 C를 레이저로 연결하기 위해서 설치해야 하는 거울 개수의 최소 값을 구하는 문제
- 거울을 설치한다는 것은 직선의 방향을 바꾸는 것이라고 볼 수 있다.
- 거울의 개수는 두 C를 연결하는데 필요한 직선의 최소 개수 - 1이라고 볼 수 있다.
- BFS에서 다음 정점을 인접한 네 방향에 있는 점만 넣는 것이 아니고 네 방향에 있는 모든 점을 넣는 방식으로 바꿔서 해결하면 된다.
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int m = Integer.parseInt(stk.nextToken());
        int n = Integer.parseInt(stk.nextToken());
        char[][] board = new char[n][m];
        int[][] count = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(count[i],-1);
        }
        ArrayDeque<Node> q = new ArrayDeque<>();
        int endX = 0, endY = 0;
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                board[i][j] = s.charAt(j);
                if (board[i][j] == 'C') {
                    if (q.isEmpty()) {
                        q.add(new Node(j, i));
                        count[i][j]=0;
                    } else {
                        endX = j;
                        endY = i;
                    }
                }
            }
        }
        while (!q.isEmpty()) {
            Node node = q.poll();
            int x = node.x;
            int y = node.y;
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                while(nx >= 0 && ny >= 0 && nx < m && ny < n){
                    if(board[ny][nx]=='*') break;
                    if(count[ny][nx]==-1){
                        count[ny][nx] = count[y][x] + 1;
                        q.add(new Node(nx,ny));
                    }
                    nx += dx[i];
                    ny += dy[i];
                }
            }
        }
        System.out.println(count[endY][endX]-1);
    }

    static class Node  {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```
</div>
</details>

<details>
<summary>14. 소수 경로</summary>
<div markdown='1'>

- 두 네자리 소수 N과 M이 주어졌을 때, N을 M으로 바꾸는 최소 변환 횟수를 구하는 문제
- 한 번에 N에서 한 자리만 바꿀 수 있고, 바꾼 숫자도 소수이어야 한다.
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        boolean[] isPrime = new boolean[10000];
        Arrays.fill(isPrime,true);
        for (int i = 2; i*i <10000 ; i++) {
            if(isPrime[i]){
                for (int j = i*i; j < 10000; j+=i) {
                    isPrime[j] = false;
                }
            }
        }
        int t = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        while(t-- > 0){
            StringTokenizer stk = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(stk.nextToken());
            int b = Integer.parseInt(stk.nextToken());
            int[] visited = new int[10000];
            boolean success = false;
            Arrays.fill(visited,-1);
            ArrayDeque<Integer> q = new ArrayDeque<>();
            q.add(a);
            visited[a]= 0;
            while(!q.isEmpty()){
                int now = q.poll();
                if(now == b){
                    sb.append(visited[now]).append('\n');
                    success = true;
                    break;
                }
                int[] save = {now/1000,(now/100)%10,(now/10)%10,now%10};
                for (int i = 0; i <4; i++) {
                    int tmp = save[i];
                    for (int j = (tmp+1)%10; j!=tmp; j = (j+1)%10) {
                        if(i==0&&j==0) continue;
                        int next = makeNumber(save,i,j);
                        if(isPrime[next]&&visited[next]==-1){
                            visited[next] = visited[now]+1;
                            q.add(next);
                        }
                    }
                    save[i] = tmp;
                }
            }
            if(!success){
                sb.append("Impossible\n");
            }
        }
        System.out.print(sb);
    }
    static int makeNumber(int[] digits, int i,int j){
        digits[i] = j;
        int result = 0;
        for (int k = 0; k < 4; k++) {
            result += digits[k]*(int)Math.pow(10,3-k);
        }
        return result;
    }
}
```
</div>
</details>

<details>
<summary>15. 적록색약</summary>
<div markdown='1'>

- N x N 크기의 격자가 있고, 각 칸에는 R,G,B 중 하나의 색이 색칠되어져 있다.
- 같은 색상이 인접하는 경우 두 구역은 같은 그림이다.
- 적록색약인 사람은 빨간색과 초록색의 차이를 느끼지 못한다.
- BFS를 일반 사람이 봤을 때와, 적록색약이 봤을 때로 나누어서 두 번 구현하면 된다.

나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    static int n,m;
    static int[] dx ={-1,1,0,0},dy={0,0,1,-1};
    static char[][] board;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        board = new char[n][n];
        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < n; j++) {
                board[i][j] = s.charAt(j);
            }
        }
        System.out.println(bfs1()+" "+bfs2());
    }
    static int bfs1(){
        int result = 0;
        boolean[][] visited = new boolean[n][n];
        ArrayDeque<Node> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if(!visited[i][j]){
                    result++;
                    visited[i][j] = true;
                    q.add(new Node(j,i,board[i][j]));
                    while (!q.isEmpty()){
                        Node node = q.poll();
                        int x = node.x;
                        int y = node.y;
                        char c = node.c;
                        for (int k = 0; k < 4; k++) {
                            int nx = x + dx[k];
                            int ny = y + dy[k];
                            if(nx>=0&&ny>=0&&nx<n&&ny<n&&!visited[ny][nx]){
                                char next = board[ny][nx];
                                if(c==next){
                                    visited[ny][nx] = true;
                                    q.add(new Node(nx,ny,next));
                                }
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    static int bfs2(){
        int result = 0;
        boolean[][] visited = new boolean[n][n];
        ArrayDeque<Node> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if(!visited[i][j]){
                    result++;
                    visited[i][j] = true;
                    q.add(new Node(j,i,board[i][j]));
                    while (!q.isEmpty()){
                        Node node = q.poll();
                        int x = node.x;
                        int y = node.y;
                        char c = node.c;
                        for (int k = 0; k < 4; k++) {
                            int nx = x + dx[k];
                            int ny = y + dy[k];
                            if(nx>=0&&ny>=0&&nx<n&&ny<n&&!visited[ny][nx]){
                                char next = board[ny][nx];
                                if((c=='R'||c=='G')&&(next=='R'||next=='G')){
                                    visited[ny][nx] = true;
                                    q.add(new Node(nx,ny,next));
                                }else if(c=='B'&&next=='B'){
                                    visited[ny][nx] = true;
                                    q.add(new Node(nx,ny,next));
                                }
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    static class Node{
        int x;
        int y;
        char c;
        public Node(int x, int y,char c) {
            this.x = x;
            this.y = y;
            this.c = c;
        }
    }
}
```
</div>
</details>

<details>
<summary>16. 4연산</summary>
<div markdown='1'>

- 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 문제
- s = s + s (출력: +)
- s = s - s (출력: -)
- s = s * s (출력: *)
- s = s / s (출력: /) (s가 0이 아닐때만 사용 가능)
- 1 <= s <= 10^9
- BFS 탐색 문제이다.
- 만들어지는 수의 개수는 최대 10^9개 이다?
    + 아니다
    + x -> x * x 또는 2 * x의 형태로 변형만 가능하기 때문에 만들어지는 수는 x^a * 2^b의 형태이다.
    + a와 b에 들어갈 수 있는 수는 넉넉잡아 30보다 작다.
    + 따라서 가능한 경우의 수는 900정도 이다.
- Set을 이용해서 중복검사를 한다.

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 1000000001;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(stk.nextToken());
        int end = Integer.parseInt(stk.nextToken());
        ArrayDeque<Node> q = new ArrayDeque<>();
        HashSet<Integer> set = new HashSet<>();
        q.add(new Node(start,""));
        set.add(start);
        while (!q.isEmpty()){
            Node node = q.poll();
            int n = node.n;
            String s = node.s;
            if(n==end){
                if(s.length()==0) System.out.println(0);
                else System.out.println(s);
                return;
            }
            if(n<(int)Math.sqrt(INF)&&!set.contains(n*n)){
                set.add(n);
                q.add(new Node(n*n,s+"*"));
            }
            if(n+n<INF&&!set.contains(n+n)){
                set.add(n+n);
                q.add(new Node(n+n,s+"+"));
            }
            if(!set.contains(0)){
                set.add(0);
                q.add(new Node(0,s+"-"));
            }
            if(n!=0&&!set.contains(1)){
                set.add(1);
                q.add(new Node(1,s+"/"));
            }
        }
        System.out.println(-1);
    }
    static class Node{
        int n;
        String s;

        public Node(int n, String s) {
            this.n = n;
            this.s = s;
        }
    }
}
```
</div>
</details>

> ### 참고자료
> [CodePlus 강의 알고리즘 중급 1](https://code.plus/course/43)  